
######################################
# 文字列
######################################

	##----------------------------------------
	## 文字列を１文字ずつ配列に代入する
	##----------------------------------------
	$inputs = str_split($input_line);


	##----------------------------------------
	## 半角スペース区切りの文字列を配列に代入する
	##----------------------------------------
	$inputs = explode(' ', trim($input_line));


	##----------------------------------------
	## 逆順にする
	##----------------------------------------
	echo strrev(trim($input_line));


	##----------------------------------------
	## 文字列切り出し
	##----------------------------------------
	substr($text, 開始位置、 文字数)


	##----------------------------------------
	## 文字列を検索する
	##----------------------------------------
	strpos(検索対象の文字列, 検索する文字列)


		### 例：特定の文字列を検索する
		if(strpos($subject,'bc') !== false){
		  //'abcd'のなかに'bc'が含まれている場合
		}
		参考：https://qiita.com/kazu56/items/2c72d187438de07c2503

		### preg_matchでパターンに変数を使う場合はデリミタに{}を使う

		    $input1 = "ngword";
		    $input2 = "thisisngwor";

		    // if(strpos($input2,$input1) !== false){
		    if(preg_match('{' . $input2 . '}',$input1) !== false){
		        echo "NG";
		    }else{
		        echo $input2;
		    }


	##----------------------------------------
	## 文字列を反転する
	##----------------------------------------
	strrev ( string $string ) : string


	##----------------------------------------
	## 文字列から数字のみを抜き出す（正規表現）
	##----------------------------------------
	$input_line = "abc123abc;
	$num = preg_replace('/[^0-9]/', '', $input_line);


	##----------------------------------------
	## 特定の文字列を置き換える（正規表現）
	##----------------------------------------
	preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] ) : mixed


	##----------------------------------------
	## 文字列を指定文字で埋める処理
	##----------------------------------------
	str_pad ( string $input , int $pad_length [, string $pad_string = " " [, int $pad_type = STR_PAD_RIGHT ]] ) : string


	##----------------------------------------
	## 指定文字を削除
	##----------------------------------------
	str_replace('ab', '', $str);


	##----------------------------------------
	## 特定の文字列の出現回数をカウントする
	##----------------------------------------
	substr_count ( string $haystack , string $needle [, int $offset = 0 [, int $length ]] ) : int


	##----------------------------------------
	## chr — 数値から、1バイトの文字列を生成する
	##----------------------------------------
	chr ( int $bytevalue ) : string

		// 大文字のアルファベット A-Z を順番に出力
		for ( $i = 0; $i < 26; $i++ ) { // アルファベットの数(=26)だけ処理ループ
			print chr(65 + $i) . '<br />';
		}

		// 小文字のアルファベット a-z を順番に出力
		for ( $i = 0; $i < 26; $i++ ) { // アルファベットの数(=26)だけ処理ループ
			print chr(97 + $i) . '<br />';
		}
		参考：http://tsunagu-tsunagaru.hatenablog.jp/entry/PHP-%E3%82%A2%E3%83%AB%E3%83%95%E3%82%A1%E3%83%99%E3%83%83%E3%83%88A-Z/a-z%E3%82%92%E9%A0%86%E7%95%AA%E3%81%AB%E5%87%BA%E5%8A%9B%E3%81%99%E3%82%8B


	##----------------------------------------
	## substr_count — 副文字列の出現回数を数える
	##----------------------------------------
	substr_count ( string $haystack , string $needle [, int $offset = 0 [, int $length ]] ) : int

	※needle は英大小文字を区別することに注意してください。

		例）
		$text = 'This is a test';
		echo strlen($text); // 14

		echo substr_count($text, 'is'); // 2

		// 文字列は 's is a test' になっているので, 1 が表示される
		echo substr_count($text, 'is', 3);

		// テキストは 's i' になっているので, 0 が表示される
		echo substr_count($text, 'is', 3, 3);

		// 5+10 > 14 なので、警告が発生する
		echo substr_count($text, 'is', 5, 10);


		// 重なっている副文字列はカウントされないので、1 が表示される
		$text2 = 'gcdgcdgcd';
		echo substr_count($text2, 'gcdgcd');

######################################
# 数字
######################################

	##----------------------------------------
	## floor — 端数の切り捨て
	##----------------------------------------
	floor ( float $value ) : float

		// 100未満を切り捨て
		echo floor((1980)/100)*100; // 1900

		// 例
		echo floor(4.3);   // 4
		echo floor(9.999); // 9
		echo floor(-3.14); // -4

	##----------------------------------------
	## ceil — 端数の切り上げ
	##----------------------------------------
	ceil ( float $value ) : float

		// 日数計算
		echo ceil($value / 24);


	##----------------------------------------
	## 配列内の最大値、最小値
	##----------------------------------------
	max, min


	##----------------------------------------
	## ２進数を１０進数に変換
	##----------------------------------------
	bindec ( string $binary_string ) : number


	##----------------------------------------
	## １０進数を２進数に変換
	##----------------------------------------
	decbin ( int $number ) : string


	##----------------------------------------
	## 小数点以下を表示する
	##----------------------------------------
	number_format ( float $number [, int $decimals = 0 ] ) : string


	##----------------------------------------
	## pi — 円周率の値を得る
	##----------------------------------------
	pi ( void ) : float

		echo pi(); // 3.1415926535898
		echo M_PI; // 3.1415926535898
		echo substr(pi(), 0, (3 + 2)) // 3.141

######################################
# 配列
######################################

	##----------------------------------------
	## 配列を比較し、差分を出力する
	##----------------------------------------
	$result = array_diff($a, $b);

	foreach ($result as $value) {
	    echo $value;
	}

	##----------------------------------------
	## 配列内のソート
	##----------------------------------------
	sort ( array &$array [, int $sort_flags = SORT_REGULAR ] ) : bool

	##----------------------------------------
	## 配列内の合計
	##----------------------------------------
	array_sum ( array $array ) : number

	##----------------------------------------
	## array_search — 指定した値を配列で検索し、見つかった場合に対応する最初のキーを返す
	##----------------------------------------

	array_search ( mixed $needle , array $haystack [, bool $strict = FALSE ] ) : mixed

	見つかった場合に配列のキー、 それ以外の場合に FALSE を返します。


	##----------------------------------------
	## array_count_values — 配列の値の数を数える
	##----------------------------------------
	array_count_values ( array $array ) : array

	array_count_values() は、 配列 array の値をキーとし、 array におけるその値の出現回数を値とした配列を返します。


		例）
		$array = array(1, "hello", 1, "world", "hello");
		print_r(array_count_values($array));


		Array
		(
		    [1] => 2
		    [hello] => 2
		    [world] => 1
		)

	##----------------------------------------
	## list — 配列と同様の形式で、複数の変数への代入を行う
	##----------------------------------------
	list ( mixed $var1 [, mixed $... ] ) : array

		例）
		$info = array('コーヒー', '茶色', 'カフェイン');

		// すべての変数の取得
		list($drink, $color, $power) = $info;
		echo "$drink の色は $color で、$power が含まれています。\n";

		// 一部の変数の取得
		list($drink, , $power) = $info;
		echo "$drink には $power が含まれています。\n";

		// 三番目のみの取得
		list( , , $power) = $info;
		echo "$power 欲しい!\n";

		// list() は文字列では動作しません
		list($bar) = "abcde";
		var_dump($bar); // NULL

	##----------------------------------------
	## array_map — 指定した配列の要素にコールバック関数を適用する
	##----------------------------------------
	array_map ( callable $callback , array $array1 [, array $... ] ) : array


		例）
		function cube($n)
		{
		    return ($n * $n * $n);
		}

		$a = [1, 2, 3, 4, 5];
		$b = array_map('cube', $a);
		print_r($b);


		結果）
		Array
		(
		    [0] => 1
		    [1] => 8
		    [2] => 27
		    [3] => 64
		    [4] => 125
		)

	##################
	## +演算子とarray_merge関数の違い
	##################

	+ 演算子は、同一キーに対し、上書きしない。
	array_merge は同一キーに対し、上書きする。


		例）
		$a = array(
		    'a' => 'apple',
		    'b' => 'bear',
		    'c' => 'coffee',
		);

		$b = array(
		    'a' => 'ant',
		    'b' => 'bug',
		    'd' => 'deep',
		);

		echo "\$a + \$b\n";
		$c = $a + $b;
		print_r($c);

		echo "array_merge(\$a, \$b)\n";
		$c = array_merge($a, $b);
		print_r($c);

		echo "\$b + \$a\n";
		$c = $b + $a;
		print_r($c);

		echo "array_merge(\$b, \$a)\n";
		$c = array_merge($b, $a);
		print_r($c);


		## 結果
		$a + $b
		Array
		(
		    [a] => apple
		    [b] => bear
		    [c] => coffee
		    [d] => deep
		)

		array_merge($a, $b)
		Array
		(
		    [a] => ant
		    [b] => bug
		    [c] => coffee
		    [d] => deep
		)

		$b + $a
		Array
		(
		    [a] => ant
		    [b] => bug
		    [d] => deep
		    [c] => coffee
		)

		array_merge($b, $a)
		Array
		(
		    [a] => apple
		    [b] => bear
		    [d] => deep
		    [c] => coffee
		)

######################################
# 正規表現
######################################

	##----------------------------------------
	## preg_match — 正規表現によるマッチングを行う
	##----------------------------------------
	preg_match ( string $pattern , string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0 ]]] ) : int

	pattern

		検索するパターンを表す文字列。

		subject
		入力文字列。

		matches
		matches を指定した場合、検索結果が代入されます。 $matches[0] にはパターン全体にマッチしたテキストが代入され、 $matches[1] には 1 番目のキャプチャ用サブパターンにマッチした 文字列が代入され、といったようになります。

		flags
		flags には以下のフラグの組み合わせを指定できます。

		PREG_OFFSET_CAPTURE
		このフラグを設定した場合、各マッチに対応する文字列のオフセットも(バイト単位で)返されます。 これは、matches の値を配列に変更することに注意してください。 その配列のすべての要素は、 オフセット 0 で一致した文字列、 およびその文字列のオフセット 1 での subject へのオフセットからなります。

######################################
# 標準入力
######################################

	##----------------------------------------
	## 基本パターン（trimしないとゴミが付いていてハマることがある）
	##----------------------------------------
	$inp = trim(fgets(STDIN));


	##----------------------------------------
	## 標準入力を一行ずつ配列に代入
	##----------------------------------------
	while ($line = (fgets(STDIN))) {
	   $tmp[] = trim($line);
	}


	##----------------------------------------
	## 配列の各要素をさらに分解します
	##----------------------------------------
	foreach ($tmp as $key => $value) {
	  $array[] = explode(" ", $value);
	}


	##----------------------------------------
	## スペースで区切られた２つの文字を読み込み、変数に代入する
	##----------------------------------------
	fscanf(STDIN,"%d %d",$a,$b);

	※３つ以上の入力も可能


	##----------------------------------------
	## コーディングテスト用
	## 3つの入力を読んですべて0の場合はループを抜ける
	##----------------------------------------

	## 書き方その1(fscanf)
	while(true){
	    fscanf(STDIN, '%d %d %d', $a, $b, $c);
	    if($a+$b+$c==0){
	        break;
	    }
	}

	## 書き方その2(list)
	while (1) {
		list($a, $b, $c) = explode(' ', trim(fgets(STDIN)));
	    if($a+$b+$c==0){
	        break;
	    }
	}


	##----------------------------------------
	# ゾロ目判定
	##----------------------------------------

    $input_line = trim(fgets(STDIN));
    $inputs = str_split($input_line);
    $old = $inputs[0];

    foreach ($inputs as $value) {
        
        $new = $value;
        
        if($old === $new){
            $old = $value;
        }else{
            echo "No";
            exit();
        }
    }

    echo $input_line;


######################################
# 日時
######################################

	##----------------------------------------
	## 秒から時分秒を生成する	
	##----------------------------------------
    $hour = floor($inp / 3600);
    $min = floor(($inp / 60) % 60);
    $sec = $inp % 60;


	##----------------------------------------
	## HH:MM:DDの形式で出力
	##----------------------------------------
    $format = "%02d:%02d:%02d";
    echo sprintf($format, $hour, $min, $sec);


######################################
# 演算子
######################################

	$value ? "Yes" : "No"

	>$valueがtrueならYes、falseならNo


	$_COOKIE['email'] ?? ''

	>COOKIEがセットされていたら出力、されていなかったらブランク


######################################
# COOKIE
######################################

	セットされているCOOKIEの一覧確認方法

	chromeのデペロッパーツールでCookiesで確認できる


######################################
# PATH
######################################

	pathinfo ( string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] ) : mixed


	path
	調べたいパス。

	options
	指定する場合は、どの要素を返すのかを PATHINFO_DIRNAME、 PATHINFO_BASENAME、 PATHINFO_EXTENSION あるいは PATHINFO_FILENAME のいずれかで指定します。

	options を省略した場合はすべての要素を返します。


		例）
		<?php
		$path_parts = pathinfo('/www/htdocs/inc/lib.inc.php');

		echo $path_parts['dirname'], "\n";
		echo $path_parts['basename'], "\n";
		echo $path_parts['extension'], "\n";
		echo $path_parts['filename'], "\n"; // PHP 5.2.0 以降
		?>


		出力例）
		/www/htdocs/inc
		lib.inc.php
		php
		lib.inc

######################################
# その他
######################################

	##----------------------------------------
	## 排他的論理和(XOR)
	##----------------------------------------
	A	B	A XOR B
	0	0	0
	0	1	1
	1	0	1
	1	1	0

	A	B	C	A XOR B XOR C
	0	0	0	0
	1	0	0	1
	0	1	0	1
	0	0	1	1
	1	1	0	0
	1	0	1	0
	0	1	1	0
	1	1	1	1

	参考：https://augusuto04.hatenablog.com/entry/2015/05/04/034037


	##----------------------------------------
	## 配列検索
	##----------------------------------------
	$header = ["店舗ID", "店舗名", "グループ名"];
	$data = [
	    [
		'id' => 1,
		'name' => "テスト店舗1",
		'group' => "テストグループ1"
	    ],
	    [
		'id' => 2,
		'name' => "テスト店舗2",
		'group' => "テストグループ2"
	    ],
	    [
		'id' => 3,
		'name' => "テスト店舗3",
		'group' => "テストグループ3"
	    ],
	];

	$test = array_search(2, array_column($data, 'id'));
	// $test = array_search("検索ワード", array_column("検索対象の配列", '検索するカラム'));

	var_dump($data[$test]['name']);

